def GetPulse(sREC, db2Filter, sOPTION): # blCntr, blNorm):
    '''
    L3 of the bout pipeline: Identifies pulses of activity using a sliding
    cosine similarity between the signal contained in sREC.db2LFP and
    spatio-temporal motifs (i.e. filter) contained in db2Filter. The best
    result will be obtained when the signal and template have been centered
    to their mean and normalized by their S.D.. In the case the cosine
    similarity is equivalent to the correlation. 

    NOTE: This alternative version does not center (align to the mean) but
    aligns to the minimum of signal and filter).

    Input -------------------------------------------------------------------

    sREC:     a structure requiring the following fields:
           -.db2LFP a (channel x time sample) matrix containing the signal
           (i.e. time series) of interest.
           -.db2LFP_Rnd a (channel x time sample) matrix containing the
           surrogate signal (generated by
           CBASS_L1_AddPhaseRandomizedSignal) --- Will be computed if
           omitted.
           -.inSampleRate a positive number representing the sample rate
           of the time series.
    db2Filter a (channel x time sample) matrix describing the template motif.
           The number of time samples is typically one period of the
           median frequency of the band of interest
    blCntr    (optional) a boolean setting whether signal and template
           should be centered about their mean. Default is true.
    blNorm    (optional) a boolean setting whether signal and template should
           be normalized by their S.D.. Default is true.

    Output ------------------------------------------------------------------

    sPULSE:   a structure array containing the following fields:
           -.db1Score the score of the template matching. A vector having
           as many elements as time samples in sREC.db2LFP.
           -.bl1Peak a boolean indexing the local maxima in db1Score
           -.db1Score_H0 the score obtained on surrogate data
           -.bl1Peak_H0 a boolean indexing local maxima on db1Score_H0
           -.dbThrPeak the theshold for significance for peaks.
           Significant peaks are considered pulses of band specific
           activity. Set as the 95 percentile of
           sPULSE.db1Score_H0(sPULSE.bl1Peak_H0)
           -.bl1Pulse a boolean indexing significant pulses of band
           specific activity. It has as many elements as time samples in
           sREC.db2LFP. <----- FINAL OUTPUT OF THE PROCEDURE.
           -dbP_KS the p-value of a Kolmogorov-Smirnov test of the
           difference between the distrubutions of score values at peak in
           the LFP and in the surrogate data 
           -dbP_Rate the p-value of a binomial test of the occurence of
           significant pulses in the real data compared to the surrogate
           data (where it is set as 5 by definition - see field
           .db1ThrPeak).

    '''
    verbose = sOPTION.blVerbose
    class sPULSE: # Initializes the L3 pulse structure
        pass
    sPULSE.db1Score = []
    sPULSE.bl1Peak = []
    sPULSE.db1Score_H0=[]
    sPULSE.bl1Peak_H0 = []
    sPULSE.dbThrPeak = []
    sPULSE.bl1Pulse = []
    sPULSE.dbP_KS=[]
    sPULSE.dbP_Rate = []


    # Runs template matching, detects the peaks and computes the enveloppe
    db1Score    = MultiChannelTemplateMatching(sREC.db2LFP, db2Filter, sOPTION.blCntr, sOPTION.blNorm).squeeze()
    if verbose: print('db1Score.shape: ', db1Score.shape)
    bl1Peak = np.concatenate((np.array([False]),(np.diff(db1Score[:-1])>0) & (np.diff(db1Score[1:])<0),np.array([False])))
    # db1Env      = abs(hilbert(db1Score));


    # Runs the template matching on the phase randomized LFP, detects the peaks and computes the enveloppe
    db1Score_H0     = MultiChannelTemplateMatching(sREC.db2LFP_Rnd, db2Filter, sOPTION.blCntr, sOPTION.blNorm).squeeze()
    if verbose: print('db1Score_H0.shape: ', db1Score_H0.shape)
    bl1Peak_H0 = np.concatenate((np.array([False]),(np.diff(db1Score_H0[:-1])>0) & (np.diff(db1Score_H0[1:])<0),np.array([False])))

    # Detects significant peak: i.e. pulses
    dbThrPeak   = np.quantile(db1Score_H0[bl1Peak_H0], .95)
    bl1Pulse    = bl1Peak & (db1Score > dbThrPeak)


    # Tests that the distribution is different and gives a warning if not
    [blSig, dbP_KS] = ks_2samp(db1Score[bl1Peak], db1Score_H0[bl1Peak_H0])
    if verbose: print('[blSig, dbP_KS]: {},{}'.format(blSig, dbP_KS))
    if blSig>0.05: print('Peak distribution is not different from noise')


    # Stores the result in the output structure
    sPULSE.db1Score     = db1Score;
    sPULSE.bl1Peak      = bl1Peak;
    sPULSE.db1Score_H0  = db1Score_H0;
    sPULSE.bl1Peak_H0   = bl1Peak_H0;
    sPULSE.dbThrPeak    = dbThrPeak;
    sPULSE.bl1Pulse     = bl1Pulse;
    
    return sPULSE

import numpy as np
from scipy.stats import norm

def MergeFilters(labels, bl1T_Epoch, sCLU, cFILTER, dbRate_All, in1Sel, in1CluKM, verbose):
    '''
    [UPDATE THIS DESCRIPTION]
    L3 of the bout pipeline: Identifies pulses of activity using a sliding
    cosine similarity between the signal contained in sREC.db2LFP and
    spatio-temporal motifs (i.e. filter) contained in db2Filter. The best
    result will be obtained when the signal and template have been centered
    to their mean and normalized by their S.D.. In the case the cosine
    similarity is equivalent to the correlation. 

    NOTE: This alternative version does not center (align to the mean) but
    aligns to the minimum of signal and filter).

    Input -------------------------------------------------------------------

    sREC:     a structure requiring the following fields:
           -.db2LFP a (channel x time sample) matrix containing the signal
           (i.e. time series) of interest.
           -.db2LFP_Rnd a (channel x time sample) matrix containing the
           surrogate signal (generated by
           CBASS_L1_AddPhaseRandomizedSignal) --- Will be computed if
           omitted.
           -.inSampleRate a positive number representing the sample rate
           of the time series.
    db2Filter a (channel x time sample) matrix describing the template motif.
           The number of time samples is typically one period of the
           median frequency of the band of interest
    blCntr    (optional) a boolean setting whether signal and template
           should be centered about their mean. Default is true.
    blNorm    (optional) a boolean setting whether signal and template should
           be normalized by their S.D.. Default is true.

    Output ------------------------------------------------------------------

    sPULSE:   a structure array containing the following fields:
           -.db1Score the score of the template matching. A vector having
           as many elements as time samples in sREC.db2LFP.
           -.bl1Peak a boolean indexing the local maxima in db1Score
           -.db1Score_H0 the score obtained on surrogate data
           -.bl1Peak_H0 a boolean indexing local maxima on db1Score_H0
           -.dbThrPeak the theshold for significance for peaks.
           Significant peaks are considered pulses of band specific
           activity. Set as the 95 percentile of
           sPULSE.db1Score_H0(sPULSE.bl1Peak_H0)
           -.bl1Pulse a boolean indexing significant pulses of band
           specific activity. It has as many elements as time samples in
           sREC.db2LFP. <----- FINAL OUTPUT OF THE PROCEDURE.
           -dbP_KS the p-value of a Kolmogorov-Smirnov test of the
           difference between the distrubutions of score values at peak in
           the LFP and in the surrogate data 
           -dbP_Rate the p-value of a binomial test of the occurence of
           significant pulses in the real data compared to the surrogate
           data (where it is set as 5 by definition - see field
           .db1ThrPeak).

    '''

    class sFILTER:
        pass

    sFILTER = sFILTER()
    sFILTER.in1CluSel = []
    sFILTER.bl1Member = []
    sFILTER.inNObs = []
    sFILTER.dbRate = []
    sFILTER.dbRate_Dev = []
    sFILTER.dbPVal = []
    sFILTER.db2Filter=[]
    sFILTER.blSig_FDR = []

    # Calculates the filters 
    inNFlt = len(np.unique(labels))
    for iFlt in range(inNFlt):
        if verbose: print('labels: ',labels)
        if verbose: print('iFlt: ',iFlt)
        if verbose: print('in1Sel: ', in1Sel)
        if verbose: print('np.where(labels == iFlt)[0]: ',np.where(labels == iFlt)[0])
        in1CluSel   = in1Sel[np.where(labels == iFlt)[0]];
        if verbose: 
            print('in1CluKM: ',in1CluKM)
            print('in1CluKM.min(): ',in1CluKM.min())
            print('in1CluKM.max(): ',in1CluKM.max())
        if verbose: 
            print('in1CluSel: ',in1CluSel)
            print('in1CluSel.min(): ',in1CluSel.min())
            print('in1CluSel.max(): ',in1CluSel.max())
        bl1Member   = np.in1d(in1CluKM, in1CluSel) # indices of the cluster
        if verbose: 
            print('bl1Member: ',bl1Member)
            print('bl1Member.shape: ',bl1Member.shape)
        if verbose: 
            print('bl1Member[:10]: ',bl1Member[:10])
            print('bl1Member[:10].shape: ',bl1Member[:10].shape)
            print('in1CluSel[:10]: ',in1CluSel[:10])
            print('in1CluKM[:10]: ',in1CluKM[:10])
        inNObs      = np.sum(bl1Member) # number of points in the cluster
        sFILTER.in1CluSel.append(in1CluSel) # K-means cluster used to build the filter
        sFILTER.bl1Member.append(bl1Member) # Membership boolean vector
        sFILTER.inNObs.append(inNObs)       # Number of troughs.

        # Recalculate rates and pvalues
        if verbose: print('bl1T_Epoch[bl1Member]: ',bl1T_Epoch[bl1Member])
        dbRate                     = np.mean(bl1T_Epoch[bl1Member])  # Calculates the ratio
        if verbose: print('dbRate: ',dbRate)
        dbRate_Dev                 = dbRate - dbRate_All;
        sFILTER.dbRate.append(dbRate) # Stores the ratio
        sFILTER.dbRate_Dev.append(dbRate_Dev)    # Stores the ratio
        if verbose: print('dbRate_Dev: ',dbRate_Dev)
        pval = np.nanmin([1, 2 * (1 - norm.cdf(np.abs(dbRate_Dev)/np.sqrt(dbRate_All * (1 - dbRate_All)/ inNObs)))])
        if verbose: print('pval: ',pval)
        sFILTER.dbPVal.append(pval)

        # Calculates the mean filter
        if verbose: print('np.array(in1CluSel): ',np.array(in1CluSel))
        db1Weight   = np.array(sCLU.inNObs)[np.array(in1CluSel)];
        if verbose: print('np.where(labels == iFlt)[0]: ', np.where(labels == iFlt)[0])

        if verbose: print('np.array(cFILTER)[np.where(labels == iFlt)[0]].shape: ', np.array(cFILTER)[np.where(labels == iFlt)[0]].shape)
        cFILTER_Selected = np.array(cFILTER)[np.where(labels == iFlt)[0]]
        if verbose: 
            print('cFILTER_Selected.shape: ', cFILTER_Selected.shape)
            print('db1Weight.shape: ',db1Weight.shape)

        for idx in range(len(db1Weight)):
            cFILTER_Selected[idx,:,:] = cFILTER_Selected[idx,:,:]*db1Weight[idx]
        db2Filter = np.sum(cFILTER_Selected,axis=0)/np.sum(db1Weight)
        sFILTER.db2Filter.append(db2Filter)
        
    return sFILTER
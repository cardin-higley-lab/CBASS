function [sFREQ_BAND, cTROUGH, cTRGH_RND] = ...
    CBASS_Main_DetectEvents(db2LFP, inSampleRate, cBAND, cSTATE, sOPTION)
% Main function for the detection of enriched band specific activity motif.
% Chance levels of detection and significance levels are estimated by
% repeating procedures on surrogate data having the same spectral density 
% the same covariance matrix between channels. The surrogate data are
% generated with the function:  CBASS_L1_AddPhaseRandomizedSignal.
% The function makes use of 2 additional subroutines:
%
% CBASS_L1_GetTrough:       performs trough identification of real and
%                           surrogate signals using the Hilbert transform.
% CBASS_L2_PartitionTrough: identifies a groups of troughs having a high
%                           probability of occuring during the state of 
%                           interest baseed on spectro-temporal dynamics.
% 
%
% Input -------------------------------------------------------------------
% db2LFP:       a (channel x time sample) matrix containing the signal of
%               interest - originaly meant to be a recording of the Local 
%               Field Potential(LFP) but it can be any multichannel time 
%               series.
% inSampleRate: a positive number describing the sampling rate of the
%               signal
% cBAND:        a (1 x 2) array describing the frequency band of interest
%               i.e. [30 80] for 30 to 80 Hz OR several such arrays
%               grouped in a cell array. The analysis will be performed
%               for each element.
% cSTATE:       a logical vector, containing as many elements as time
%               samples in db2LFP, indexing the state in which enriched
%               band specific activity is observed OR a cell array of such
%               vector. If so the number of element of the cell array must
%               mach the number of element in cBAND.
%
% Option structure --------------------------------------------------------
% The variable sOPTION can be used to pass optional arguments. It may
% contain the following fields:
%
% .cBAND_LABEL:     a cell array of size matching cBAND containings labels
%                   for the band of interest - (i.e. 'gamma' for [30 80Hz])
% .chDataFormat:    a character array specifying the format of the hilbert
%                   transforms output. Can be 'complex' or 'polar'. Default
%                   is 'complex'.
% .inRefChan:       a number specifying a reference channel. Events will be
%                   aligned to the trought of the band specific activity in
%                   that channel for trough identification. Default is the
%                   last channel of db2LFP.
% .cBASELINE        a logical vector, containing as many elements as time
%                   samples in db2LFP, indexing the state in which enriched
%                   band specific activity is NOT observed OR a cell array
%                   of such vector. If so the number of element of the cell
%                   array must mach the number of element in cBAND.
% .blZScore:        logical specifying if trought data is to be zscored for 
%                   k-means partitioning. Default is true.
% .inNClu:          number of cluster used for k-means partitioning.
%                   Default is 20
% .dbSigThrs:       threshold for the significance of the enrichment in 
%                   trough partition.  P-Values are computed with a 
%                   binomial test. Default is 10.^-4.
% .inNIter:         iteration used by the k-means algorithm. Default is 
%                   1000.
% .blVerbose:       logical setting whether processing updates should be
%                   displayed in the command window. Default is true.
%
% Output ------------------------------------------------------------------
% sFREQ_BAND:       a structure array of the same size as cBAND containing
%                   the following fields:
%   .db1Band        The value of cBAND for that instance of the array
%   .chBandLabel    The label of the band for that instance of the array 
%                   (may be specified in sOPTION.cBAND_LABEL).
%   .in1TroughIdx   the indices of the trough of oscillatory activity in
%                   sREC.db2LFP used to define activity templates (Troughs
%                   are generated by CBASS_L1_GetTrough).
%   .db1Score       a score representing an estimate of the probability of
%                   trough to occur during the state of interest based on
%                   spectro-temporal features
%   .db1ScoreRnd    the same score calculated on trought extracted from
%                   surrogate data
%   .dbP_KS         the p-value of a Kolmogorov-Smirnov test of the
%                   difference between the distrubutions of score values in
%                   the LFP and in the surrogate data
%   .dbThreshold    a threshold giving the partition of values of db1Score
%                   resulting in the most significant distance between
%                   troughs based on spectro-temporal features
%   .dbPValThr      p-value for the significance of the partition.
%                   Calculated as the proportion of db1ScoreRnd above
%                   dbThreshold
%   .bl1Partition   a logical vector indexing the trough retained as final
%                   events
%   .bl1Event       a boolean, having as many elements as time samples in
%                   db2LFP, indexing significant event of state
%                   enriched band specific activity. <---  FINAL OUTPUT
%
% Optional Output ---------------------------------------------------------
% cTROUGH           a cell array containing the output of the subroutine
%                   CBASS_L1_GetTrough for each frequency band in cBAND.
%                   Each instance of cTROUGH is a structure sTROUGH
%                   containing the following fields:
%   .db1FilterBand  an (1 x 2) array describing the frequency
%                   band of interest i.e. [30 80] for 30 to 80 Hz.
%   .db2Trough      a (2 * channel x trough) matrix containing the
%                   hilbert transform of each channel of sREC.db2LFP filtered
%                   in the band defined in sTROUGH.db1FilterBand at the trough
%                   of the filtered signal in the reference channel inRefChan
%   .in1Index       the indices of the trough in sREC.db2LFP
%
% cTRGH_RND         a cell array containing the output of the subroutine
%                   CBASS_L1_GetTrough for each frequency band in cBAND
%                   applied to the surrogate signal generated by
%                   CBASS_L1_AddPhaseRandomizedSignal. Each instance of
%                   cTRGH_RND is a structure sTRGH_RND containing the same
%                   fields as the elements of cTROUGH (see above)
 


%Checks the number of arguments -------------------------------------------
narginchk(4, 5);
if nargin < 5, sOPTION = struct; end

%Checks for non optional arguments ----------------------------------------
[cBAND, cSTATE, inNChan, bl1Remove] = CheckArg(db2LFP, inSampleRate, cBAND, cSTATE); % Function at the end of the script

% Deals with the option structure -----------------------------------------
sOPTION = CheckOption(sOPTION, cBAND, cSTATE, inNChan, bl1Remove); % Function at the end for the script

% Computes ----------------------------------------------------------------
    %Formats the LFP and computes the phase randomized signal (this will be
    %used for chance level estimation and statistical testing)
if sOPTION.blVerbose, fprintf('---->> Compute phase randomized signal ... '); end
sREC.db2LFP         = db2LFP;
sREC.inSampleRate   = inSampleRate;
sREC                = CBASS_L1_AddPhaseRandomizedSignal(sREC);
if sOPTION.blVerbose, fprintf('Done\n'); end

    %Initializes the output structure
inNBnd = length(cBAND); 
sFREQ_BAND = struct();

    %Initializes the optional output cell arrays
[cTROUGH, cTRGH_RND] = deal(cell(size(cBAND))); 

    %Loops through bands of interest 
for iBnd = 1:inNBnd
    % Choose the state of interest
    if sOPTION.blVerbose, fprintf('\n------ %s ---------------------------\n', sOPTION.cBAND_LABEL{iBnd}); end
    bl1State    = cSTATE{iBnd};

    % Extracts trougths for the real and surrogates signals
    if sOPTION.blVerbose, fprintf('---->> Extract hilbert troughs ... '); end
    sTROUGH     = CBASS_L1_GetTrough(sREC.db2LFP, inSampleRate, cBAND{iBnd}, ...
        sOPTION.inRefChan, sOPTION.cBAND_LABEL{iBnd}, sOPTION.chDataFormat);
    sTRGH_RND   = CBASS_L1_GetTrough(sREC.db2LFP_Rnd, inSampleRate, cBAND{iBnd}, ... 
        sOPTION.inRefChan, sOPTION.cBAND_LABEL{iBnd}, sOPTION.chDataFormat);
    if sOPTION.blVerbose, fprintf('Done\n'); end
    
    % Partitions troughs
    if sOPTION.blVerbose, fprintf('---->> Partition troughs ... '); end
    sPART       = CBASS_L2_PartitionTrough(sTROUGH, bl1State, ...
        sOPTION.cBASELINE{iBnd}, sOPTION.blZScore, sOPTION.inNClu, ...
        sOPTION.dbSigThrs, sOPTION.inNIter);
    sPRT_RND    = CBASS_L2_PartitionTrough(sTRGH_RND, bl1State, ...
        sOPTION.cBASELINE{iBnd}, sOPTION.blZScore, sOPTION.inNClu, ...
        sOPTION.dbSigThrs, sOPTION.inNIter);
    if sOPTION.blVerbose, fprintf('Done\n'); end
    
    % Computes control variable (prints them if wanted)
	[~, dbP_KS] = kstest2(sPART.db1Score, sPRT_RND.db1Score);
    dbPValThr   = mean(sPRT_RND.db1Score > sPART.dbThreshold);
    if sOPTION.blVerbose
        if dbP_KS < 0.05, chKS_Sig = ''; else, chKS_Sig = 'NON'; end
        fprintf('Score: \t\t%s SIGNIFICANT \t(p = %.3f, KS Test - real vs surrogate data)\n', chKS_Sig, dbP_KS);
        if dbPValThr < 0.05, chSig = ''; else, chSig = 'NON'; end
        fprintf('Partition: \t%s SIGNIFICANT \t(p = %.3f, Fraction of surrogate troughs above threshold)\n', ...
            chSig, dbPValThr); 
    end
    
    % Computes a boolean indexing event (the final selection of troughs)
    bl1Event    = false(1, size(db2LFP, 2));
    bl1Event(sTROUGH.in1Index(sPART.bl1Partition)) = true;
    
    % Aggregates pulse data
    sFREQ_BAND(iBnd).db1Band        = cBAND{iBnd};
    sFREQ_BAND(iBnd).chBandLabel    = sOPTION.cBAND_LABEL{iBnd};
    sFREQ_BAND(iBnd).in1TroughIdx   = sTROUGH.in1Index;
    sFREQ_BAND(iBnd).db1Score       = sPART.db1Score;
    sFREQ_BAND(iBnd).db1ScoreRnd    = sPRT_RND.db1Score;
    sFREQ_BAND(iBnd).dbP_KS         = dbP_KS;
    sFREQ_BAND(iBnd).dbThreshold    = sPART.dbThreshold;
    sFREQ_BAND(iBnd).dbPValThr      = dbPValThr;
    sFREQ_BAND(iBnd).bl1Partition   = sPART.bl1Partition;
    sFREQ_BAND(iBnd).bl1Event       = bl1Event;
    
    % Aggregate intermediary steps
    cTROUGH{iBnd}   = sTROUGH;
    cTRGH_RND{iBnd} = sTRGH_RND;
end

%------------------------------------------------------------------------------------------------  
function [cBAND, cSTATE, inNChan, bl1Remove] = CheckArg(db2LFP, inSampleRate, cBAND, cSTATE)
%Utility to check non optional arguments

% Checks that the signal is a 2D matrix
if ~ismatrix(db2LFP); error('The signal must be a (channel x time sample) matrix'); end
[inNChan, inNSamp] = size(db2LFP);

% Check sample rate
if ~(numel(inSampleRate) > 1 || any(mod(inSampleRate(:), 0) ~= 0))
    error('The sample rate must be a single positive number')
end

% Checks if states and band are not cell array
if ~iscell(cBAND); cBAND = {cBAND}; end
if ~iscell(cSTATE); cSTATE = {cSTATE}; end

% Checks that cBAND and cSTATE are properly formatted and have the same size
if ~isvector(cBAND); error('cBAND must be a vector cell array'); end
if ~isvector(cSTATE); error('cSTATE must be a vector cell array'); end
if iscolumn(cBAND); cBAND = cBAND'; end
if iscolumn(cSTATE); cSTATE = cSTATE'; end
if any(size(cBAND) ~= size(cSTATE)); error('cSTATE and cBAND must have the same size'); end

% Checks if on the entry of the state and bands is properly formated
bl1BandCorrect = cellfun(@(x) all(size(x) == [1 2]) & all(x > 0), cBAND);
if any(~bl1BandCorrect)
    fprintf('Some instances of cBAND are improperly formatted and will be skipped\r');
end
bl1StateCorrect = cellfun(@(x) isvector(x) & islogical(x) & numel(x) == inNSamp, cSTATE);
if any(~bl1StateCorrect)
    fprintf('Some instances of cSTATE are improperly formatted and will be skipped\r');
end
    
% Skips improperly formatted input
bl1Remove   = ~bl1BandCorrect | ~bl1StateCorrect;
cBAND(bl1Remove)    = [];
cSTATE(bl1Remove)   = [];
if isempty(cSTATE); error('No valid entry for state and/or frequency bands'); end

%------------------------------------------------------------------------------------------------
function sOPTION = CheckOption(sOPTION, cBAND, cSTATE, inNChan, bl1Remove)
% Utility to check the options structure. Makes use of the utility
% CheckField present at the end of the script

% Checks the band label
blLblErr = false;
if ~isfield(sOPTION, 'cBAND_LABEL')
    sOPTION.cBAND_LABEL = cellfun(@(x) sprintf('%d-%dHz', x(1), x(2)), cBAND, 'UniformOutput' , false); 
elseif ~iscell(sOPTION.cBAND_LABEL)
    if ischar(sOPTION.cBAND_LABEL), sOPTION.cBAND_LABEL = {sOPTION.cBAND_LABEL};
    else, sOPTION.cBAND_LABEL = cellfun(@(x) sprintf('%d-%dHz', x(1), x(2)), cBAND, 'UniformOutput' , false); 
        blLblErr = true; 
    end
elseif ~all(size(sOPTION.cBAND_LABEL) == size(bl1Remove))   
    sOPTION.cBAND_LABEL = cellfun(@(x) sprintf('%d-%dHz', x(1), x(2)), cBAND, 'UniformOutput' , false); blLblErr = true;
else
    sOPTION.cBAND_LABEL(bl1Remove) = [];
    in1Wrong = find(~cellfun(@ischar, sOPTION.cBAND_LABEL));
    for iWrg = in1Wrong
        sOPTION.cBAND_LABEL{iWrg} = sprintf('%d-%dHz', cBAND{iWrg}(1), cBAND{iWrg}(2));
        fprintf('Instance %d of sOPTION.cBAND_LABEL was set to default\r', iWrg);
    end
end
if blLblErr, fprintf('sOPTION.cBAND_LABEL is not valid. Set to default\r'); end

% Checks L1 options for formatting hilbert troughs
sOPTION = CheckField(sOPTION, 'chDataFormat', @(x) ~ismember(x, {'polar', 'complex'}), 'complex');
sOPTION = CheckField(sOPTION, 'inRefChan', @(x) numel(x) > 1 || any(mod(x(:), 1) ~= 0) || any(x(:) > inNChan), inNChan);

% Checks L2 options for the computation of filters
    % Checks baseline option argument
blBasErr = false;
if ~isfield(sOPTION, 'cBASELINE')
    sOPTION.cBASELINE = cellfun(@(x) ~x, cSTATE, 'UniformOutput' , false);
elseif ~iscell(sOPTION.cBASELINE)
    if islogical(sOPTION.cBASELINE) & all(size(sOPTION.cBASELINE) == cSTATE{1}), sOPTION.cBASELINE = {sOPTION.cBASELINE};
    else, sOPTION.cBASELINE = cellfun(@(x) ~x, cSTATE, 'UniformOutput' , false); blBasErr = true; end
elseif ~all(size(sOPTION.cBASELINE) == size(bl1Remove))
    sOPTION.cBASELINE = cellfun(@(x) ~x, cSTATE, 'UniformOutput' , false); blBasErr = true;
else
    sOPTION.cBASELINE(bl1Remove) = [];
    for iTst = 1:2
        if iTst == 1, in1Wrong = find(~cellfun(@(x, y) islogical(x) & all(size(x) == size(y)), sOPTION.cBASELINE, cSTATE));
        else, in1Wrong = find(cellfun(@(x, y) any(x & y), sOPTION.cBASELINE, cSTATE)); end
        for iWrg = in1Wrong
            sOPTION.cBASELINE{iWrg} = ~cSTATE{iWrg};
            fprintf('Instance %d of sOPTION.cBASELINE was set to default\r', iWrg);
        end
    end
end
if blBasErr, fprintf('sOPTION.cBASELINE does not match the format of cSTATE. Set to default\r'); end
    % Checks other optional arguments
sOPTION = CheckField(sOPTION, 'blZScore', @(x) numel(x) > 1 || any(~islogical(x(:))), true);
sOPTION = CheckField(sOPTION, 'inNClu', @(x) numel(x) > 1 || any(mod(x(:), 1) ~= 0) || any(x(:) <= 0), 20);
sOPTION = CheckField(sOPTION, 'dbSigThrs', @(x) numel(x) > 1 || any(x(:) <= 0) || any(x(:) > 1), 10.^-4);
sOPTION = CheckField(sOPTION, 'inNIter', @(x) numel(x) > 1 || any(mod(x(:), 1) ~= 0) || any(x(:) <= 0), 10000);
sOPTION = CheckField(sOPTION, 'blVerbose', @(x) numel(x) > 1 || any(~islogical(x(:))), true);


function sOPTION = CheckField(sOPTION, chField, fCOND, DefaultVal)
% Utility to check the field of an option
if ~isfield(sOPTION, chField),  sOPTION.(chField) = DefaultVal; end
if fCOND(sOPTION.(chField))
    fprintf('sOPTION.%s is not valid. Set to default\r', chField);
    sOPTION.(chField) = DefaultVal;
end
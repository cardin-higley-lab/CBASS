function [sFILTER, sCLU, in1CluKM, in1Sel, in1CluSC] = CBASS_L2_GetFitlters(sREC, sTROUGH, sTRGH_RND, bl1Epoch, ...
    bl1Baseline, blZScore, inMethod, inNClu, dbSigThrs, inNMaxIter, blVerbose)
% L2 of the bout pipeline: Generate template motifs of activity in the band
% of interst enriched for the state indexed by the logical vector bl1Epoch.
% The algorithm separates a set of events of the input signal sREC.db2LFP
% into an aribitrary number of clusters using the k-means algorithm. These
% events are the output of CBASS_L1_GetTrough and correspond to the trougths
% of oscilatory activity at the band of interest in a reference channel.
% They are represented as the Hilbert transform of the band filtered
% activity of each channel. Clusters are then sorted as a function of the
% fraction of the events they comprise that occured during the state
% defined by bl1Epoch. Clusters that are significantly 'enriched' in events
% occuring during this state are used to defined templates activity motifs.
% These motifs represent the average signal activity around the events of
% the clusters. Enriched clusters are then grouped as a function of the
% similarity of the motifs they generate using spectral clustering. Grouped
% clusters are used to generate a final set of template activity motifs
% returned in the function sFILTER.
%
% Input -------------------------------------------------------------------
%
% sREC:         a structure having the following fields:
%               -.db2LFP a (channel x time sample) matrix containing the
%               signal (i.e. time series) of interest. 
%               -.db2LFP_Rnd a (channel x time sample) matrix containing 
%               the surrogate signal (generated by 
%       `       CBASS_L1_AddPhaseRandomizedSignal)
%               -.inSampleRate a positive number representing the sample
%               rate of the time series.
% sTROUGH:      the output of CBASS_L1_GetTrough (i.e.) a structure
%               requiring the following fields:
%               -.db1FilterBand an (1 x 2) array describing the frequency
%               band of interest i.e. [30 80] for 30 to 80 Hz.
%               -.db2Trough  a (2 * channel x trough) matrix containing the
%               hilbert transform of each channel of sREC.db2LFP filtered
%               in the band defined in sTROUGH.db1FilterBand at the trough
%               of the filtered signal in a reference channel (see
%               CBASS_L1_GetTrough for more detail)
%               -.in1Index the indices of the trough in sREC.db2LFP
% sTRGH_RND:    a structure formatted as sTROUGH containing troughs
%               computed from the surrogate data (generated by
%               CBASS_L1_AddPhaseRandomizedSignal and stored in
%               sREC.db2LFP_Rnd).
% bl1Epopch:    a logical vector, containing as many elements as time
%               samples in db2LFP, indexing the state in which enriched
%               band specific activity is observed.
% bl1Baseline:  (optional) a logical vector, containing as many elements as
%               time samples in db2LFP, indexing the state in which band
%               specific activity is not observed. There should be no
%               overlap between bl1Baseline and bl1Epoch. Default is
%               ~bl1Epoch.
% blZScore:     (optional) logical specifying if trought data is to be
%               zscored for k-means partitioning. Default is true.
% inMethod:     (optional) single integer with value 1 or 2. Determines the
%               method used to set the threshold of similarity used to
%               retain an edge in spectral clustering during the grouping
%               of templates. Method 1 sets a general threshold as the
%               average similarity of templates identified on surrogate
%               data. Method 2 sets a threshold for each edge as the
%               maximum simarity between its nodes and a chance template
%               computed as the average activity around all troughs in the
%               surrogate data. Method 2 identifies more templates, but
%               these templates will generate overlapping sets of pulses.
%               Default is 1.
% inNClu:       (optional) number of cluster used for k-means partitioning.
%               Default is 20
% dbSigThrs:    (optional) threshold for the significance of the enrichment
%               in trough partition.  P-Values are computed with a binomial 
%               test. Default is 10.^-4.
% inNMaxIter:   (optional) maximum iteration used by the k-means algorithm.
%               Default is 10000.
% blVerbose:    (optional) logical setting whether processing updates
%               should be displayed in the command window. Default is true.
%
% Output ------------------------------------------------------------------
%
% sFILTER     	a structure array storing templates for activity motifs and
%               containing the following fields:
%               -.in1CluSel a vector containing the indices of the k-means
%               clusters used to build the filter
%               -.bl1Member a boolean indexing troughs used to build the
%               template motif
%               -.inNObs the number of troughs in sFILTER.bl1Member.
%               -.dbRate the fraction of the troughs occuring during the
%               state of interest.
%               -.dbRate_Dev the enrichment for the state of interest i.e.
%               sFILTER.dbRate minus the overall ratio of troughs occuring
%               during the state of interest
%               -.dbPVal the p-value of a binomial test of the of dbRate
%               compared to the overall rate of occurence of the state of
%               interest.
%               -.db2Filter a (channel x time sample) matrix describing the
%               template motif. The number of time samples is one period of
%               the median frequency of the band of interest.
% sCLU          a structure array storing the clusters of the k-means
%               partitioning and having the following fields:
%               -.bl1Member a boolean indexing troughs used to build the
%               template motif
%               -.inNObs the number of troughs in sCLU.bl1Member.
%               -.dbRate the fraction of the troughs occuring during the
%               state of interest.
%               -.dbRate_Dev the enrichment for the state of interest i.e.
%               sCLU.dbRate minus the overall ratio of troughs occuring
%               during the state of interest
%               -.dbPVal the p-value of a binomial test of the of dbRate
%               compared to the overall rate of occurence of the state of
%               interest.

% Sets optional parameters if not provided
narginchk(4, 12);
if ~exist('bl1Baseline', 'var'), bl1Baseline = ~bl1Epoch; elseif isempty(bl1Baseline), bl1Baseline = ~bl1Epoch; end
if ~exist('blZScore', 'var'), blZScore = true; elseif isempty(blZScore), blZScore = true; end
if ~exist('inMethod', 'var'), inMethod = 1; elseif isempty(inMethod), inMethod = 1; end
if ~exist('inNClu', 'var'), inNClu = 20; elseif isempty(inNClu), inNClu = 20; end
if ~exist('dbSigThrs', 'var'), dbSigThrs = 10.^-4; elseif isempty(dbSigThrs), dbSigThrs = 10.^-4; end
if ~exist('inNMaxIter', 'var'), inNMaxIter = 1000; elseif isempty(inNMaxIter), inNMaxIter = 1000; end
if ~exist('blVerbose', 'var'), blVerbose = true; elseif isempty(blVerbose), blVerbose = true; end

% Checks that bl1Epoch and bl1Baseline are non empty and non overlapping
if ~any(bl1Epoch), error('bl1Epoch does not index any time sample'); end
if ~any(bl1Baseline), error('bl1Baseline does not index any time sample'); end
if any(bl1Epoch & bl1Baseline); error('bl1Epoch and bl1Baseline are overlapping'); end

% initializes the random number generator
rng(1949);  
 
% Formats the data
if blZScore, db2Data = zscore(sTROUGH.db2Trough);
else, db2Data = sTROUGH.db2Trough; end

% Print informations on the screen
if blVerbose
    fprintf('\r------ %d CLUSTERS ---------------------------\r', inNClu)
end

% Cluster the data
in1CluKM = kmeans(db2Data, inNClu, 'MaxIter', inNMaxIter);

% Computes the indices of the troughs recorded during the enriched epoch
% and during baseline
bl1T_Epoch      = bl1Epoch(sTROUGH.in1Index);
bl1T_Baseline   = bl1Baseline(sTROUGH.in1Index);

% Computes the overall ratio of running points in the data
dbRate_All      = sum(bl1T_Epoch)./sum(bl1T_Epoch | bl1T_Baseline);

% Initialize a cluster structure containing stats for enrichment
sCLU = struct('bl1Member', cell(1, inNClu), ...
    'inNObs', cell(1, inNClu), ...
    'dbRate', cell(1, inNClu), ...
    'dbRate_Dev', cell(1, inNClu), ...
    'dbPVal', cell(1, inNClu));

% Loops over clusters
for iClu = 1:inNClu
    bl1Member   = in1CluKM == iClu; % indices of the cluster
    inNObs      = sum(bl1Member); % number of points in the cluster
    sCLU(iClu).bl1Member    = bl1Member;
    sCLU(iClu).inNObs       = inNObs;
    
    % Calculate the ratio of running points for the cluster and the p-value
    % of that ratio under H0 i.e. the hypothesis that the ratio is the same
    % that in the overall population. The p-value is calculated using a
    % binomial distribution.
    dbRate                  = sum(bl1T_Epoch(bl1Member))/sum(bl1T_Epoch(bl1Member) | bl1T_Baseline(bl1Member)); % Calculates the ratio
    inNObsTest              = sum(bl1T_Epoch(bl1Member)) + sum(bl1T_Baseline(bl1Member));
    dbRate_Dev              = dbRate - dbRate_All;
    sCLU(iClu).dbRate       = dbRate; % Stores the ratio
    sCLU(iClu).dbRate_Dev   = dbRate_Dev; % Stores the ratio
    sCLU(iClu).dbPVal       = nanmin([1, 2 * (1 - normcdf(abs(dbRate_Dev)./...
        sqrt(dbRate_All * (1 - dbRate_All) ./ inNObsTest)))]);
end

% Determines whos significant
cSIG = num2cell(fdr_bh([sCLU.dbPVal], dbSigThrs));
[sCLU.blSig_FDR] = cSIG{:};

%%% Print the results
% Sort the cluster by ratio
if blVerbose
    [~, in1Sort] = sort([sCLU.dbRate_Dev]);
    
    % Initialize a significance statement array
    cSTATEMENT = {'NON SIG' 'SIG'};
    
    % Loops throught clusters
    for iClu = in1Sort
        fprintf('Cluster %2d (N = %d):\tRate: %.4f\tDev: %.3f\t(p = %.4f)\t%s\r', ...
            iClu, sCLU(iClu).inNObs, sCLU(iClu).dbRate, sCLU(iClu).dbRate_Dev, sCLU(iClu).dbPVal, ...
            cSTATEMENT{sCLU(iClu).blSig_FDR + 1});
    end
end

% Makes filters for significantly enriched regions
%Finds signigicantly enriched regions
in1Sel = find([sCLU.dbRate_Dev] > 0 & [sCLU.dbPVal] < dbSigThrs);
if isempty(in1Sel)
    disp('No enriched regions');
    sFILTER = [];
    return
end

% Sets the filter length
dbCycLen            = 1./mean(sTROUGH.db1FilterBand);
db1Filter_WinSec    = [-dbCycLen dbCycLen] / 2;

% Get the filter for each enriched region
cFILTER = {}; db2FiltMat = [];
for iClu = in1Sel
    % Makes the filter
    in1EventIdx = sTROUGH.in1Index(sCLU(iClu).bl1Member);
    db2Filter   = CBASS_U_MakeFilter(sREC.db2LFP, sREC.inSampleRate, in1EventIdx, db1Filter_WinSec);
    
    % Aggregates the pulse events for the cluster of interest
    cFILTER     = cat(2, cFILTER, {db2Filter});
    db2FiltMat  = cat(2, db2FiltMat, db2Filter(:));
end

% Clusters filters;
switch inMethod
    case 1 % Sets the threshold as the average correlation fitler generated on random data

        % Formats the data
        if blZScore, db2Data = zscore(sTRGH_RND.db2Trough);
        else, db2Data = sTRGH_RND.db2Trough; end
        
        % Cluster the data
        in1CluKM_Rnd = kmeans(db2Data, inNClu, 'MaxIter', inNMaxIter);
        
        % Get the filter for each enriched region
        db2FiltMat_Rnd = [];
        for iClu = 1:inNClu
            % Makes the filter
            in1EventIdx = sTRGH_RND.in1Index(in1CluKM_Rnd == iClu);
            db2Filter   = CBASS_U_MakeFilter(sREC.db2LFP_Rnd, sREC.inSampleRate, in1EventIdx, db1Filter_WinSec);
            
            % Aggregates the pulse events for the cluster of interest
            db2FiltMat_Rnd  = cat(2, db2FiltMat_Rnd, db2Filter(:));
        end
        
        %Calculates the correlations between random fitlers and sets the
        %threshold
        db2Corr_Rnd = corr(db2FiltMat_Rnd);
        db1Corr_Rnd   = []; 
        for iEv = 1:size(db2Corr_Rnd, 1) - 1
            db1Corr_Rnd = cat(1, db1Corr_Rnd, db2Corr_Rnd(iEv + 1:end, iEv));
        end
        dbThrsMean  = mean(db1Corr_Rnd);
                  
        %Calculate the correlation between fitlters and sets those inferior
        %to the threshold to zero to built the adjacency matrix
        db2Adj = corr(db2FiltMat);
        db2Adj(db2Adj < max(dbThrsMean, 0)) = 0;
         
    case 2 % Only keeps an edge if its weight is superior to the correlation of each of its node to a random filter
        
        % Built the average filter generated by randomized data
        db2Filter_Rnd       = CBASS_U_MakeFilter(sREC.db2LFP_Rnd, sREC.inSampleRate, sTRGH_RND.in1Index, db1Filter_WinSec);
        
        % concatenate the random fitlers with the filters and calcuates
        % their correlation
        db2FiltMat  = [db2Filter_Rnd(:) db2FiltMat];
        db2Corr     = corr(db2FiltMat);
        
        % Builds the adjacency matrix
        db1Thr = db2Corr(2:end, 1);
        db2Thr = max(db1Thr, db1Thr');
        db2Adj = db2Corr(2:end, 2:end);
        db2Adj(db2Adj < db2Thr) = 0;
end

% Performs spectral clustering
in1CluSC    = CBASS_U_SpectralCluster(db2Adj);
inNFlt      = max(in1CluSC);

% Initialize a filter structure containing stats for enrichment
sFILTER = struct('in1CluSel', cell(1, inNFlt), ...
    'bl1Member', cell(1, inNFlt), ...
    'inNObs', cell(1, inNFlt), ...
    'dbRate', cell(1, inNFlt), ...
    'dbRate_Dev', cell(1, inNFlt), ...
    'dbPVal', cell(1, inNFlt));

% Calculates the filters 
for iFlt = 1:inNFlt
    in1CluSel   = in1Sel(in1CluSC == iFlt);
    bl1Member   = ismember(in1CluKM, in1CluSel); % indices of the cluster
    inNObs      = sum(bl1Member); % number of points in the cluster
    sFILTER(iFlt).in1CluSel     = in1CluSel; % K-means cluster used to build the filter
    sFILTER(iFlt).bl1Member     = bl1Member; % Membership boolean vector
    sFILTER(iFlt).inNObs        = inNObs;    % Number of troughs.
    
    % Recalculate rates and pvalues
    dbRate                      = sum(bl1T_Epoch(bl1Member))/sum(bl1T_Epoch(bl1Member) | bl1T_Baseline(bl1Member)); % Calculates the ratio
    inNObsTest                  = sum(bl1T_Epoch(bl1Member)) + sum(bl1T_Baseline(bl1Member));
    dbRate_Dev                  = dbRate - dbRate_All;
    sFILTER(iFlt).dbRate        = dbRate; % Stores the ratio
    sFILTER(iFlt).dbRate_Dev    = dbRate_Dev; % Stores the ratio
    sFILTER(iFlt).dbPVal        = nanmin([1, 2 * (1 - normcdf(abs(dbRate_Dev)./...
        sqrt(dbRate_All * (1 - dbRate_All) ./ inNObsTest)))]);
    
    % Calculates the mean filter
    db1Weight   = [sCLU(in1CluSel).inNObs];
    db2Filter   = sum(cat(3, cFILTER{in1CluSC == iFlt}) .* permute(db1Weight(:), [3 2 1]), 3)./sum(db1Weight);
    sFILTER(iFlt).db2Filter     = db2Filter;
end

% Determines whos significant
cSIG = num2cell(fdr_bh([sFILTER.dbPVal], dbSigThrs));
[sFILTER.blSig_FDR] = cSIG{:};

if blVerbose
    fprintf('\r------ %d FILTER ---------------------------\r', inNFlt)
    
        % Loops throught clusters
    for iFlt = 1:inNFlt
        fprintf('Region %2d (N = %d):\tRate: %.4f\tDev: %.3f\t(p = %.4f)\r', ...
            iFlt, sFILTER(iFlt).inNObs, sFILTER(iFlt).dbRate, sFILTER(iFlt).dbRate_Dev, sFILTER(iFlt).dbPVal);
    end
end